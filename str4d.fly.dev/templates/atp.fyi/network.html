{% extends "base.html" %}

{% block title %}Bluesky network map{% endblock %}

{% block head %}
<style>
    #content {
        position: fixed;
        inset: 0;
        display: flex;
        flex-flow: column;
    }

    #topbar {
        display: flex;
        flex-flow: row;
    }

    #toptext {
        flex: 2 1 auto;
    }

    #controls {
        flex: 1 1 auto;
        text-align: end;
    }

    #controls .switch {
        top: 3px;
    }

    #atproto-map {
        border: 1px solid lightgray;
        background: white;
        flex: 1 1 auto;
    }

    #clustersLayer {
        width: 100%;
        height: 100%;
        position: absolute;
    }

    .clusterLabel {
        position: absolute;
        transform: translate(-50%, -50%);
        font-family: sans-serif;
        font-variant: small-caps;
        font-weight: 400;
        font-size: 1.8rem;
        text-shadow:
            2px 2px 1px white,
            -2px -2px 1px white,
            -2px 2px 1px white,
            2px -2px 1px white;
    }

    .switch {
        position: relative;
        display: inline-block;
        width: 30px;
        height: 17px;
    }

    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        -webkit-transition: .4s;
        transition: .4s;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 13px;
        width: 13px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
    }

    input:checked+.slider {
        background-color: #2196F3;
    }

    input:focus+.slider {
        box-shadow: 0 0 1px #2196F3;
    }

    input:checked+.slider:before {
        -webkit-transform: translateX(13px);
        -ms-transform: translateX(13px);
        transform: translateX(13px);
    }

    .slider.round {
        border-radius: 17px;
    }

    .slider.round:before {
        border-radius: 50%;
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.26.0/graphology.umd.min.js"></script>
<script src="https://github.com/graphology/graphology/releases/download/0.26.0/graphology-library.min.js"></script>
{% endblock %}

{% block content %}
<div id="topbar">
    <div id="toptext">
        <div id="nav"><a href="/">üè† Home</a></div>

        <h1>Bluesky network map</h1>

        <div id="status-box">
            <p id="status-text"></p>
        </div>
    </div>

    <div id="controls">
        <div>Node sizes</div>
        <div>
            PDSs (accounts): Linear
            <label class="switch">
                <input type="checkbox" id="pds-size-log">
                <span class="slider round"></span>
            </label>
            Log
        </div>
        <div>
            Relays (rate): Linear
            <label class="switch">
                <input type="checkbox" id="relay-size-log" checked>
                <span class="slider round"></span>
            </label>
            Log
        </div>
        <div>
            Labelers (likes): Linear
            <label class="switch">
                <input type="checkbox" id="labeler-size-log">
                <span class="slider round"></span>
            </label>
            Log
        </div>
        <div>
            Feeds (likes): Linear
            <label class="switch">
                <input type="checkbox" id="feed-size-log">
                <span class="slider round"></span>
            </label>
            Log
        </div>
        <div>
            AppViews (rate): Linear
            <label class="switch">
                <input type="checkbox" id="appview-size-log" checked>
                <span class="slider round"></span>
            </label>
            Log
        </div>
    </div>
</div>

<div id="atproto-map"></div>

<script type="text/javascript">
    const kinds = {
        Pds: "input",
        Relay: "middle",
        Labeler: "middle",
        Feed: "output",
        AppView: "output",
    };
    const groups = {
        Pds: "PDSs",
        Relay: "Relays",
        Labeler: "Labelers",
        Feed: "Feeds",
        AppView: "AppViews",
    };
    const bskyColour = "#1185fe";
    const colours = {
        Pds: "blue",
        Relay: "orange",
        Labeler: "red",
        Feed: "grey",
        AppView: "green",
    };
    const clusterColours = {
        PDSs: "Pds",
        Relays: "Relay",
        Labelers: "Labeler",
        Feeds: "Feed",
        AppViews: "AppView",
    };

    const sizeLog = {
        PDSs: document.getElementById('pds-size-log'),
        Relays: document.getElementById('relay-size-log'),
        Labelers: document.getElementById('labeler-size-log'),
        Feeds: document.getElementById('feed-size-log'),
        AppViews: document.getElementById('appview-size-log'),
    };

    function graphMap(map) {
        // Create a graphology graph
        const graph = new graphology.Graph();
        map.nodes.forEach((node, index) => {
            graph.addNode(index, {
                kind: kinds[node.group],
                group: groups[node.group],
                subgroup: node.subgroup,
                label: node.label,
                lin_size: node.lin_size,
                log_size: node.log_size,
                color: node.bsky_operated ? bskyColour : colours[node.group],
            });
        });
        map.edges.forEach((edge) => {
            graph.addEdge(edge.from, edge.to, {
                size: edge.size,
                color: edge.colour,
            });
        });

        // Initialise clusters from graph data
        const groupClusters = {};
        graph.forEachNode((_node, atts) => {
            if (!groupClusters[atts.group]) {
                groupClusters[atts.group] = {
                    label: atts.group,
                    color: colours[clusterColours[atts.group]],
                    positions: []
                };
            }
        });

        function updateNodeSizesAndPositions() {
            // Update the node sizes
            graph.forEachNode((node, atts) => {
                atts.size = sizeLog[atts.group].checked ? atts.log_size : atts.lin_size;
            });

            // Position the graph nodes
            graphologyLibrary.layout.circlepack.assign(graph, {
                hierarchyAttributes: ["kind", "group", "subgroup"],
            });

            // Calculate each cluster's nodes barycenter to use for the cluster's label position
            for (const group in groupClusters) {
                const cluster = groupClusters[group];
                cluster.positions = [];
            }
            graph.forEachNode((node, atts) => {
                const cluster = groupClusters[atts.group];
                cluster.positions.push({ x: atts.x, y: atts.y });
            });
            for (const group in groupClusters) {
                const cluster = groupClusters[group];
                cluster.x = cluster.positions.reduce((acc, p) => acc + p.x, 0) / cluster.positions.length;
                cluster.y = cluster.positions.reduce((acc, p) => acc + p.y, 0) / cluster.positions.length;
            }
        }
        updateNodeSizesAndPositions();

        // Instantiate sigma.js and render the graph
        const container = document.getElementById("atproto-map");
        const renderer = new Sigma(graph, container, {
            labelRenderedSizeThreshold: 1000000
        });

        // Bind the size controls:
        for (const group in sizeLog) {
            const control = sizeLog[group];
            control.addEventListener('change', () => {
                updateNodeSizesAndPositions();

                // Refresh rendering
                renderer.refresh({
                    // We don't touch the graph data so we can skip its reindexation
                    skipIndexation: true,
                });
            })
        }

        // Create the clustersLabel layer
        const clustersLayer = document.createElement("div");
        clustersLayer.id = "clustersLayer";
        let clusterLabelsDoms = "";
        for (const group in groupClusters) {
            // fFor each cluster create a div label
            const cluster = groupClusters[group];
            // Adapt the position to viewport coordinates
            const viewportPos = renderer.graphToViewport(cluster);
            clusterLabelsDoms += `<div id='${cluster.label}' class="clusterLabel" style="top:${viewportPos.y}px;left:${viewportPos.x}px;color:${cluster.color}">${cluster.label}</div>`;
        }
        clustersLayer.innerHTML = clusterLabelsDoms;

        // Insert the layer underneath the hovers layer
        container.insertBefore(clustersLayer, container.querySelector(".sigma-hovers"));

        // Declare internal state:
        const state = {};

        function setHoveredNode(node) {
            if (node) {
                state.hoveredNode = node;
                state.hoveredNodeGroup = graph.getNodeAttribute(node, "group");
                state.hoveredNeighbors = new Set(graph.neighbors(node));
            }

            if (!node) {
                state.hoveredNode = undefined;
                state.hoveredNodeGroup = undefined;
                state.hoveredNeighbors = undefined;
            }

            // Refresh rendering
            renderer.refresh({
                // We don't touch the graph data so we can skip its reindexation
                skipIndexation: true,
            });
        }

        function toggleSelectedNode(node) {
            if (state.selectedNode !== node) {
                state.selectedNode = node;
                state.selectedNodeGroup = graph.getNodeAttribute(node, "group");
                state.selectedNeighbors = new Set(graph.neighbors(node));
            } else {
                state.selectedNode = undefined;
                state.selectedNodeGroup = undefined;
                state.selectedNeighbors = undefined;
            }

            // Refresh rendering
            renderer.refresh({
                // We don't touch the graph data so we can skip its reindexation
                skipIndexation: true,
            });
        }

        // Bind graph interactions:
        renderer.on("enterNode", ({ node }) => {
            setHoveredNode(node);
        });
        renderer.on("clickNode", ({ node }) => {
            toggleSelectedNode(node);
        });
        renderer.on("leaveNode", () => {
            setHoveredNode(undefined);
        });

        // Render nodes accordingly to the internal state:
        // 1. If there is a selected or hovered relay node, all non-neighbor nodes are greyed
        renderer.setSetting("nodeReducer", (node, data) => {
            const res = { ...data };

            if (state.selectedNodeGroup === "Relays") {
                if (state.selectedNeighbors && !state.selectedNeighbors.has(node) && state.selectedNode !== node) {
                    res.color = "#f6f6f6";
                }
            } else if (state.hoveredNodeGroup === "Relays") {
                if (state.hoveredNeighbors && !state.hoveredNeighbors.has(node) && state.hoveredNode !== node) {
                    res.color = "#f6f6f6";
                }
            }

            return res;
        });

        // Render edges accordingly to the internal state:
        // 1. The edge is hidden if it is not connected to the selected or hovered node.
        renderer.setSetting("edgeReducer", (edge, data) => {
            const res = { ...data };

            if (state.selectedNode) {
                if (
                    !graph.extremities(edge).every((n) => n === state.selectedNode || graph.areNeighbors(n, state.selectedNode))
                ) {
                    res.hidden = true;
                }
            } else {
                if (
                    !graph.extremities(edge).every((n) => n === state.hoveredNode || graph.areNeighbors(n, state.hoveredNode))
                ) {
                    res.hidden = true;
                }
            }

            return res;
        });

        // Cluster label positions need to be updated on each render
        renderer.on("afterRender", () => {
            for (const group in groupClusters) {
                const cluster = groupClusters[group];
                const clusterLabel = document.getElementById(cluster.label);
                if (clusterLabel) {
                    // Update position from the viewport
                    const viewportPos = renderer.graphToViewport(cluster);
                    clusterLabel.style.top = `${viewportPos.y}px`;
                    clusterLabel.style.left = `${viewportPos.x}px`;
                }
            }
        });
    }

    const statusText = document.getElementById('status-text');

    statusText.textContent = "Building network map...";

    fetch("/api/network-map")
        .then((response) => {
            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            return response.json();
        })
        .then((map) => {
            statusText.textContent = "Click on a node to toggle selection. Services operates by Bluesky PBC are in light blue. Feeds cluster is very incomplete (missing data source).";
            graphMap(map);
        })
        .catch((error) => {
            console.error(error);
            statusText.textContent = `Failed to load data: ${error}`;
        });
</script>

{% endblock %}