{% extends "base.html" %}

{% block title %}Bluesky network map{% endblock %}

{% block head %}
<style>
    #content {
        position: fixed;
        inset: 0;
        display: flex;
        flex-flow: column;
    }

    #atproto-map {
        border: 1px solid lightgray;
        background: white;
        flex: 1 1 auto;
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
<script src="https://github.com/graphology/graphology/releases/download/0.25.4/graphology-library.min.js"></script>
{% endblock %}

{% block content %}
<div id="nav"><a href="/">üè† Home</a></div>

<h1>Bluesky network map</h1>

<div id="status-box">
    <p id="status-text"></p>
</div>

<div id="atproto-map"></div>

<script type="text/javascript">
    const kinds = {
        BskyPds: "input",
        Pds: "input",
        Relay: "middle",
        Labeler: "middle",
        Feed: "output",
        AppView: "output",
    };
    const groups = {
        BskyPds: "pds",
        Pds: "pds",
        Relay: "relay",
        Labeler: "labeler",
        Feed: "feed",
        AppView: "appview",
    };
    const colours = {
        BskyPds: "#1185fe",
        Pds: "blue",
        Relay: "orange",
        Labeler: "red",
        Feed: "grey",
        AppView: "green",
    };

    function graphMap(map) {
        // Create a graphology graph
        const graph = new graphology.Graph();
        map.nodes.forEach((node, index) => {
            graph.addNode(index, {
                kind: kinds[node.group],
                group: groups[node.group],
                subgroup: node.subgroup,
                label: node.label,
                size: node.size,
                color: colours[node.group],
            });
        });
        map.edges.forEach((edge) => {
            graph.addEdge(edge.from, edge.to, {
                size: edge.size,
                color: edge.colour,
            });
        });

        graphologyLibrary.layout.circlepack.assign(graph, {
            hierarchyAttributes: ["kind", "group", "subgroup"],
        });

        // Instantiate sigma.js and render the graph
        const renderer = new Sigma(graph, document.getElementById("atproto-map"), {
            labelRenderedSizeThreshold: 1000000
        });

        // Declare internal state:
        const state = {};

        function setHoveredNode(node) {
            if (node) {
                state.hoveredNode = node;
                state.hoveredNodeGroup = graph.getNodeAttribute(node, "group");
                state.hoveredNeighbors = new Set(graph.neighbors(node));
            }

            if (!node) {
                state.hoveredNode = undefined;
                state.hoveredNodeGroup = undefined;
                state.hoveredNeighbors = undefined;
            }

            // Refresh rendering
            renderer.refresh({
                // We don't touch the graph data so we can skip its reindexation
                skipIndexation: true,
            });
        }

        function toggleSelectedNode(node) {
            if (state.selectedNode !== node) {
                state.selectedNode = node;
                state.selectedNodeGroup = graph.getNodeAttribute(node, "group");
                state.selectedNeighbors = new Set(graph.neighbors(node));
            } else {
                state.selectedNode = undefined;
                state.selectedNodeGroup = undefined;
                state.selectedNeighbors = undefined;
            }

            // Refresh rendering
            renderer.refresh({
                // We don't touch the graph data so we can skip its reindexation
                skipIndexation: true,
            });
        }

        // Bind graph interactions:
        renderer.on("enterNode", ({ node }) => {
            setHoveredNode(node);
        });
        renderer.on("clickNode", ({ node }) => {
            toggleSelectedNode(node);
        });
        renderer.on("leaveNode", () => {
            setHoveredNode(undefined);
        });

        // Render nodes accordingly to the internal state:
        // 1. If there is a selected or hovered relay node, all non-neighbor nodes are greyed
        renderer.setSetting("nodeReducer", (node, data) => {
            const res = { ...data };

            if (state.selectedNodeGroup === "relay") {
                if (state.selectedNeighbors && !state.selectedNeighbors.has(node) && state.selectedNode !== node) {
                    res.color = "#f6f6f6";
                }
            } else if (state.hoveredNodeGroup === "relay") {
                if (state.hoveredNeighbors && !state.hoveredNeighbors.has(node) && state.hoveredNode !== node) {
                    res.color = "#f6f6f6";
                }
            }

            return res;
        });

        // Render edges accordingly to the internal state:
        // 1. The edge is hidden if it is not connected to the selected or hovered node.
        renderer.setSetting("edgeReducer", (edge, data) => {
            const res = { ...data };

            if (state.selectedNode) {
                if (
                    !graph.extremities(edge).every((n) => n === state.selectedNode || graph.areNeighbors(n, state.selectedNode))
                ) {
                    res.hidden = true;
                }
            } else {
                if (
                    !graph.extremities(edge).every((n) => n === state.hoveredNode || graph.areNeighbors(n, state.hoveredNode))
                ) {
                    res.hidden = true;
                }
            }

            return res;
        });
    }

    const statusText = document.getElementById('status-text');

    statusText.textContent = "Building network map...";

    fetch("/api/network-map")
        .then((response) => {
            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            return response.json();
        })
        .then((map) => {
            statusText.textContent = "";
            graphMap(map);
        })
        .catch((error) => {
            console.error(error);
            statusText.textContent = `Failed to load data: ${error}`;
        });
</script>

{% endblock %}